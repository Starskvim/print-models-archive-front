{"ast":null,"code":"/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\nconst {\n  Transform\n} = require('stream');\nconst ResizeableBuffer = require('./ResizeableBuffer');\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst tab = 9;\nconst nl = 10; // \\n, 0x0A in hexadecimal, 10 in decimal\nconst np = 12;\nconst cr = 13; // \\r, 0x0D in hexadÃ©cimal, 13 in decimal\nconst space = 32;\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\nclass Parser extends Transform {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      ...{\n        readableObjectMode: true\n      },\n      ...opts,\n      encoding: null\n    });\n    this.__originalOptions = opts;\n    this.__normalizeOptions(opts);\n  }\n  __normalizeOptions(opts) {\n    const options = {};\n    // Merge with user options\n    for (let opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    }\n    // Normalize option `encoding`\n    // Note: defined first because other options depends on it\n    // to convert chars/strings into buffers.\n    if (options.encoding === undefined || options.encoding === true) {\n      options.encoding = 'utf8';\n    } else if (options.encoding === null || options.encoding === false) {\n      options.encoding = null;\n    } else if (typeof options.encoding !== 'string' && options.encoding !== null) {\n      throw new CsvError('CSV_INVALID_OPTION_ENCODING', ['Invalid option encoding:', 'encoding must be a string or null to return a buffer,', \"got \".concat(JSON.stringify(options.encoding))], options);\n    }\n    // Normalize option `bom`\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n      options.bom = false;\n    } else if (options.bom !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', \"got \".concat(JSON.stringify(options.bom))], options);\n    }\n    // Normalize option `cast`\n    let fnCastField = null;\n    if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {\n      options.cast = undefined;\n    } else if (typeof options.cast === 'function') {\n      fnCastField = options.cast;\n      options.cast = true;\n    } else if (options.cast !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', \"got \".concat(JSON.stringify(options.cast))], options);\n    }\n    // Normalize option `cast_date`\n    if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {\n      options.cast_date = false;\n    } else if (options.cast_date === true) {\n      options.cast_date = function (value) {\n        const date = Date.parse(value);\n        return !isNaN(date) ? new Date(date) : value;\n      };\n    } else {\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', \"got \".concat(JSON.stringify(options.cast_date))], options);\n    }\n    // Normalize option `columns`\n    let fnFirstLineToHeaders = null;\n    if (options.columns === true) {\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined;\n    } else if (typeof options.columns === 'function') {\n      fnFirstLineToHeaders = options.columns;\n      options.columns = true;\n    } else if (Array.isArray(options.columns)) {\n      options.columns = normalizeColumnsArray(options.columns);\n    } else if (options.columns === undefined || options.columns === null || options.columns === false) {\n      options.columns = false;\n    } else {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an array, a function or true,', \"got \".concat(JSON.stringify(options.columns))], options);\n    }\n    // Normalize option `columns_duplicates_to_array`\n    if (options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false) {\n      options.columns_duplicates_to_array = false;\n    } else if (options.columns_duplicates_to_array !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', ['Invalid option columns_duplicates_to_array:', 'expect an boolean,', \"got \".concat(JSON.stringify(options.columns_duplicates_to_array))], options);\n    } else if (options.columns === false) {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', ['Invalid option columns_duplicates_to_array:', 'the `columns` mode must be activated.'], options);\n    }\n    // Normalize option `comment`\n    if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {\n      options.comment = null;\n    } else {\n      if (typeof options.comment === 'string') {\n        options.comment = Buffer.from(options.comment, options.encoding);\n      }\n      if (!Buffer.isBuffer(options.comment)) {\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', \"got \".concat(JSON.stringify(options.comment))], options);\n      }\n    }\n    // Normalize option `delimiter`\n    const delimiter_json = JSON.stringify(options.delimiter);\n    if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n    if (options.delimiter.length === 0) {\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', \"got \".concat(delimiter_json)], options);\n    }\n    options.delimiter = options.delimiter.map(function (delimiter) {\n      if (delimiter === undefined || delimiter === null || delimiter === false) {\n        return Buffer.from(',', options.encoding);\n      }\n      if (typeof delimiter === 'string') {\n        delimiter = Buffer.from(delimiter, options.encoding);\n      }\n      if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', \"got \".concat(delimiter_json)], options);\n      }\n      return delimiter;\n    });\n    // Normalize option `escape`\n    if (options.escape === undefined || options.escape === true) {\n      options.escape = Buffer.from('\"', options.encoding);\n    } else if (typeof options.escape === 'string') {\n      options.escape = Buffer.from(options.escape, options.encoding);\n    } else if (options.escape === null || options.escape === false) {\n      options.escape = null;\n    }\n    if (options.escape !== null) {\n      if (!Buffer.isBuffer(options.escape)) {\n        throw new Error(\"Invalid Option: escape must be a buffer, a string or a boolean, got \".concat(JSON.stringify(options.escape)));\n      }\n    }\n    // Normalize option `from`\n    if (options.from === undefined || options.from === null) {\n      options.from = 1;\n    } else {\n      if (typeof options.from === 'string' && /\\d+/.test(options.from)) {\n        options.from = parseInt(options.from);\n      }\n      if (Number.isInteger(options.from)) {\n        if (options.from < 0) {\n          throw new Error(\"Invalid Option: from must be a positive integer, got \".concat(JSON.stringify(opts.from)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: from must be an integer, got \".concat(JSON.stringify(options.from)));\n      }\n    }\n    // Normalize option `from_line`\n    if (options.from_line === undefined || options.from_line === null) {\n      options.from_line = 1;\n    } else {\n      if (typeof options.from_line === 'string' && /\\d+/.test(options.from_line)) {\n        options.from_line = parseInt(options.from_line);\n      }\n      if (Number.isInteger(options.from_line)) {\n        if (options.from_line <= 0) {\n          throw new Error(\"Invalid Option: from_line must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.from_line)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: from_line must be an integer, got \".concat(JSON.stringify(opts.from_line)));\n      }\n    }\n    // Normalize options `ignore_last_delimiters`\n    if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {\n      options.ignore_last_delimiters = false;\n    } else if (typeof options.ignore_last_delimiters === 'number') {\n      options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n      if (options.ignore_last_delimiters === 0) {\n        options.ignore_last_delimiters = false;\n      }\n    } else if (typeof options.ignore_last_delimiters !== 'boolean') {\n      throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', ['Invalid option `ignore_last_delimiters`:', 'the value must be a boolean value or an integer,', \"got \".concat(JSON.stringify(options.ignore_last_delimiters))], options);\n    }\n    if (options.ignore_last_delimiters === true && options.columns === false) {\n      throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', ['The option `ignore_last_delimiters`', 'requires the activation of the `columns` option'], options);\n    }\n    // Normalize option `info`\n    if (options.info === undefined || options.info === null || options.info === false) {\n      options.info = false;\n    } else if (options.info !== true) {\n      throw new Error(\"Invalid Option: info must be true, got \".concat(JSON.stringify(options.info)));\n    }\n    // Normalize option `max_record_size`\n    if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {\n      options.max_record_size = 0;\n    } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {\n      // Great, nothing to do\n    } else if (typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)) {\n      options.max_record_size = parseInt(options.max_record_size);\n    } else {\n      throw new Error(\"Invalid Option: max_record_size must be a positive integer, got \".concat(JSON.stringify(options.max_record_size)));\n    }\n    // Normalize option `objname`\n    if (options.objname === undefined || options.objname === null || options.objname === false) {\n      options.objname = undefined;\n    } else if (Buffer.isBuffer(options.objname)) {\n      if (options.objname.length === 0) {\n        throw new Error(\"Invalid Option: objname must be a non empty buffer\");\n      }\n      if (options.encoding === null) {\n        // Don't call `toString`, leave objname as a buffer\n      } else {\n        options.objname = options.objname.toString(options.encoding);\n      }\n    } else if (typeof options.objname === 'string') {\n      if (options.objname.length === 0) {\n        throw new Error(\"Invalid Option: objname must be a non empty string\");\n      }\n      // Great, nothing to do\n    } else {\n      throw new Error(\"Invalid Option: objname must be a string or a buffer, got \".concat(options.objname));\n    }\n    // Normalize option `on_record`\n    if (options.on_record === undefined || options.on_record === null) {\n      options.on_record = undefined;\n    } else if (typeof options.on_record !== 'function') {\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', \"got \".concat(JSON.stringify(options.on_record))], options);\n    }\n    // Normalize option `quote`\n    if (options.quote === null || options.quote === false || options.quote === '') {\n      options.quote = null;\n    } else {\n      if (options.quote === undefined || options.quote === true) {\n        options.quote = Buffer.from('\"', options.encoding);\n      } else if (typeof options.quote === 'string') {\n        options.quote = Buffer.from(options.quote, options.encoding);\n      }\n      if (!Buffer.isBuffer(options.quote)) {\n        throw new Error(\"Invalid Option: quote must be a buffer or a string, got \".concat(JSON.stringify(options.quote)));\n      }\n    }\n    // Normalize option `raw`\n    if (options.raw === undefined || options.raw === null || options.raw === false) {\n      options.raw = false;\n    } else if (options.raw !== true) {\n      throw new Error(\"Invalid Option: raw must be true, got \".concat(JSON.stringify(options.raw)));\n    }\n    // Normalize option `record_delimiter`\n    if (!options.record_delimiter) {\n      options.record_delimiter = [];\n    } else if (!Array.isArray(options.record_delimiter)) {\n      options.record_delimiter = [options.record_delimiter];\n    }\n    options.record_delimiter = options.record_delimiter.map(function (rd) {\n      if (typeof rd === 'string') {\n        rd = Buffer.from(rd, options.encoding);\n      }\n      return rd;\n    });\n    // Normalize option `relax`\n    if (typeof options.relax === 'boolean') {\n      // Great, nothing to do\n    } else if (options.relax === undefined || options.relax === null) {\n      options.relax = false;\n    } else {\n      throw new Error(\"Invalid Option: relax must be a boolean, got \".concat(JSON.stringify(options.relax)));\n    }\n    // Normalize option `relax_column_count`\n    if (typeof options.relax_column_count === 'boolean') {\n      // Great, nothing to do\n    } else if (options.relax_column_count === undefined || options.relax_column_count === null) {\n      options.relax_column_count = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count must be a boolean, got \".concat(JSON.stringify(options.relax_column_count)));\n    }\n    if (typeof options.relax_column_count_less === 'boolean') {\n      // Great, nothing to do\n    } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {\n      options.relax_column_count_less = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count_less must be a boolean, got \".concat(JSON.stringify(options.relax_column_count_less)));\n    }\n    if (typeof options.relax_column_count_more === 'boolean') {\n      // Great, nothing to do\n    } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {\n      options.relax_column_count_more = false;\n    } else {\n      throw new Error(\"Invalid Option: relax_column_count_more must be a boolean, got \".concat(JSON.stringify(options.relax_column_count_more)));\n    }\n    // Normalize option `skip_empty_lines`\n    if (typeof options.skip_empty_lines === 'boolean') {\n      // Great, nothing to do\n    } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {\n      options.skip_empty_lines = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_empty_lines must be a boolean, got \".concat(JSON.stringify(options.skip_empty_lines)));\n    }\n    // Normalize option `skip_lines_with_empty_values`\n    if (typeof options.skip_lines_with_empty_values === 'boolean') {\n      // Great, nothing to do\n    } else if (options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null) {\n      options.skip_lines_with_empty_values = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_lines_with_empty_values must be a boolean, got \".concat(JSON.stringify(options.skip_lines_with_empty_values)));\n    }\n    // Normalize option `skip_lines_with_error`\n    if (typeof options.skip_lines_with_error === 'boolean') {\n      // Great, nothing to do\n    } else if (options.skip_lines_with_error === undefined || options.skip_lines_with_error === null) {\n      options.skip_lines_with_error = false;\n    } else {\n      throw new Error(\"Invalid Option: skip_lines_with_error must be a boolean, got \".concat(JSON.stringify(options.skip_lines_with_error)));\n    }\n    // Normalize option `rtrim`\n    if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {\n      options.rtrim = false;\n    } else if (options.rtrim !== true) {\n      throw new Error(\"Invalid Option: rtrim must be a boolean, got \".concat(JSON.stringify(options.rtrim)));\n    }\n    // Normalize option `ltrim`\n    if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {\n      options.ltrim = false;\n    } else if (options.ltrim !== true) {\n      throw new Error(\"Invalid Option: ltrim must be a boolean, got \".concat(JSON.stringify(options.ltrim)));\n    }\n    // Normalize option `trim`\n    if (options.trim === undefined || options.trim === null || options.trim === false) {\n      options.trim = false;\n    } else if (options.trim !== true) {\n      throw new Error(\"Invalid Option: trim must be a boolean, got \".concat(JSON.stringify(options.trim)));\n    }\n    // Normalize options `trim`, `ltrim` and `rtrim`\n    if (options.trim === true && opts.ltrim !== false) {\n      options.ltrim = true;\n    } else if (options.ltrim !== true) {\n      options.ltrim = false;\n    }\n    if (options.trim === true && opts.rtrim !== false) {\n      options.rtrim = true;\n    } else if (options.rtrim !== true) {\n      options.rtrim = false;\n    }\n    // Normalize option `to`\n    if (options.to === undefined || options.to === null) {\n      options.to = -1;\n    } else {\n      if (typeof options.to === 'string' && /\\d+/.test(options.to)) {\n        options.to = parseInt(options.to);\n      }\n      if (Number.isInteger(options.to)) {\n        if (options.to <= 0) {\n          throw new Error(\"Invalid Option: to must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.to)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: to must be an integer, got \".concat(JSON.stringify(opts.to)));\n      }\n    }\n    // Normalize option `to_line`\n    if (options.to_line === undefined || options.to_line === null) {\n      options.to_line = -1;\n    } else {\n      if (typeof options.to_line === 'string' && /\\d+/.test(options.to_line)) {\n        options.to_line = parseInt(options.to_line);\n      }\n      if (Number.isInteger(options.to_line)) {\n        if (options.to_line <= 0) {\n          throw new Error(\"Invalid Option: to_line must be a positive integer greater than 0, got \".concat(JSON.stringify(opts.to_line)));\n        }\n      } else {\n        throw new Error(\"Invalid Option: to_line must be an integer, got \".concat(JSON.stringify(opts.to_line)));\n      }\n    }\n    this.info = {\n      bytes: 0,\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    };\n    this.options = options;\n    this.state = {\n      bomSkipped: false,\n      bufBytesStart: 0,\n      castField: fnCastField,\n      commenting: false,\n      // Current error encountered by a record\n      error: undefined,\n      enabled: options.from_line === 1,\n      escaping: false,\n      // escapeIsQuote: options.escape === options.quote,\n      escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n      // columns can be `false`, `true`, `Array`\n      expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      needMoreDataSize: Math.max(\n      // Skip if the remaining buffer smaller than comment\n      options.comment !== null ? options.comment.length : 0,\n      // Skip if the remaining buffer can be delimiter\n      ...options.delimiter.map(delimiter => delimiter.length),\n      // Skip if the remaining buffer can be escape sequence\n      options.quote !== null ? options.quote.length : 0),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map(v => v.length)),\n      trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    };\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback) {\n    if (this.state.stop === true) {\n      return;\n    }\n    const err = this.__parse(buf, false);\n    if (err !== undefined) {\n      this.state.stop = true;\n    }\n    callback(err);\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback) {\n    if (this.state.stop === true) {\n      return;\n    }\n    const err = this.__parse(undefined, true);\n    callback(err);\n  }\n  // Central parser implementation\n  __parse(nextBuf, end) {\n    const {\n      bom,\n      comment,\n      escape,\n      from_line,\n      ltrim,\n      max_record_size,\n      quote,\n      raw,\n      relax,\n      rtrim,\n      skip_empty_lines,\n      to,\n      to_line\n    } = this.options;\n    let {\n      record_delimiter\n    } = this.options;\n    const {\n      bomSkipped,\n      previousBuf,\n      rawBuffer,\n      escapeIsQuote\n    } = this.state;\n    let buf;\n    if (previousBuf === undefined) {\n      if (nextBuf === undefined) {\n        // Handle empty string\n        this.push(null);\n        return;\n      } else {\n        buf = nextBuf;\n      }\n    } else if (previousBuf !== undefined && nextBuf === undefined) {\n      buf = previousBuf;\n    } else {\n      buf = Buffer.concat([previousBuf, nextBuf]);\n    }\n    // Handle UTF BOM\n    if (bomSkipped === false) {\n      if (bom === false) {\n        this.state.bomSkipped = true;\n      } else if (buf.length < 3) {\n        // No enough data\n        if (end === false) {\n          // Wait for more data\n          this.state.previousBuf = buf;\n          return;\n        }\n      } else {\n        for (let encoding in boms) {\n          if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n            // Skip BOM\n            let bomLength = boms[encoding].length;\n            this.state.bufBytesStart += bomLength;\n            buf = buf.slice(bomLength);\n            // Renormalize original options with the new encoding\n            this.__normalizeOptions({\n              ...this.__originalOptions,\n              encoding: encoding\n            });\n            break;\n          }\n        }\n        this.state.bomSkipped = true;\n      }\n    }\n    const bufLen = buf.length;\n    let pos;\n    for (pos = 0; pos < bufLen; pos++) {\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if (this.__needMoreData(pos, bufLen, end)) {\n        break;\n      }\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n      if (to_line !== -1 && this.info.lines > to_line) {\n        this.state.stop = true;\n        this.push(null);\n        return;\n      }\n      // Auto discovery of record_delimiter, unix, mac and windows supported\n      if (this.state.quoting === false && record_delimiter.length === 0) {\n        const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n        if (record_delimiterCount) {\n          record_delimiter = this.options.record_delimiter;\n        }\n      }\n      const chr = buf[pos];\n      if (raw === true) {\n        rawBuffer.append(chr);\n      }\n      if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n        this.state.wasRowDelimiter = true;\n      }\n      // Previous char was a valid escape char\n      // treat the current char as a regular char\n      if (this.state.escaping === true) {\n        this.state.escaping = false;\n      } else {\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n        if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {\n          if (escapeIsQuote) {\n            if (this.__isQuote(buf, pos + escape.length)) {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          } else {\n            this.state.escaping = true;\n            pos += escape.length - 1;\n            continue;\n          }\n        }\n        // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n        if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n          if (this.state.quoting === true) {\n            const nextChr = buf[pos + quote.length];\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr);\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n            const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);\n            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);\n            // Escape a quote\n            // Treat next char as a regular character\n            if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {\n              pos += escape.length - 1;\n            } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {\n              this.state.quoting = false;\n              this.state.wasQuoting = true;\n              pos += quote.length - 1;\n              continue;\n            } else if (relax === false) {\n              const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', \"got \\\"\".concat(String.fromCharCode(nextChr), \"\\\"\"), \"at line \".concat(this.info.lines), 'instead of delimiter, record delimiter, trimable character', '(if activated) or comment'], this.options, this.__infoField()));\n              if (err !== undefined) return err;\n            } else {\n              this.state.quoting = false;\n              this.state.wasQuoting = true;\n              this.state.field.prepend(quote);\n              pos += quote.length - 1;\n            }\n          } else {\n            if (this.state.field.length !== 0) {\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if (relax === false) {\n                const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', \"a quote is found inside a field at line \".concat(this.info.lines)], this.options, this.__infoField(), {\n                  field: this.state.field\n                }));\n                if (err !== undefined) return err;\n              }\n            } else {\n              this.state.quoting = true;\n              pos += quote.length - 1;\n              continue;\n            }\n          }\n        }\n        if (this.state.quoting === false) {\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n          if (recordDelimiterLength !== 0) {\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n            if (skipCommentLine) {\n              this.info.comment_lines++;\n              // Skip full comment line\n            } else {\n              // Activate records emition if above from_line\n              if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                this.state.enabled = true;\n                this.__resetField();\n                this.__resetRecord();\n                pos += recordDelimiterLength - 1;\n                continue;\n              }\n              // Skip if line is empty and skip_empty_lines activated\n              if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                this.info.empty_lines++;\n                pos += recordDelimiterLength - 1;\n                continue;\n              }\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if (errField !== undefined) return errField;\n              this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n              const errRecord = this.__onRecord();\n              if (errRecord !== undefined) return errRecord;\n              if (to !== -1 && this.info.records >= to) {\n                this.state.stop = true;\n                this.push(null);\n                return;\n              }\n            }\n            this.state.commenting = false;\n            pos += recordDelimiterLength - 1;\n            continue;\n          }\n          if (this.state.commenting) {\n            continue;\n          }\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n          if (commentCount !== 0) {\n            this.state.commenting = true;\n            continue;\n          }\n          let delimiterLength = this.__isDelimiter(buf, pos, chr);\n          if (delimiterLength !== 0) {\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if (errField !== undefined) return errField;\n            pos += delimiterLength - 1;\n            continue;\n          }\n        }\n      }\n      if (this.state.commenting === false) {\n        if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n          const err = this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', \"of \".concat(max_record_size), \"at line \".concat(this.info.lines)], this.options, this.__infoField()));\n          if (err !== undefined) return err;\n        }\n      }\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr);\n      // rtrim in non quoting is handle in __onField\n      const rappend = rtrim === false || this.state.wasQuoting === false;\n      if (lappend === true && rappend === true) {\n        this.state.field.append(chr);\n      } else if (rtrim === true && !this.__isCharTrimable(chr)) {\n        const err = this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', \"at line \".concat(this.info.lines)], this.options, this.__infoField()));\n        if (err !== undefined) return err;\n      }\n    }\n    if (end === true) {\n      // Ensure we are not ending in a quoting state\n      if (this.state.quoting === true) {\n        const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', \"the parsing is finished with an opening quote at line \".concat(this.info.lines)], this.options, this.__infoField()));\n        if (err !== undefined) return err;\n      } else {\n        // Skip last line if it has no characters\n        if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n          this.info.bytes = this.state.bufBytesStart + pos;\n          const errField = this.__onField();\n          if (errField !== undefined) return errField;\n          const errRecord = this.__onRecord();\n          if (errRecord !== undefined) return errRecord;\n        } else if (this.state.wasRowDelimiter === true) {\n          this.info.empty_lines++;\n        } else if (this.state.commenting === true) {\n          this.info.comment_lines++;\n        }\n      }\n    } else {\n      this.state.bufBytesStart += pos;\n      this.state.previousBuf = buf.slice(pos);\n    }\n    if (this.state.wasRowDelimiter === true) {\n      this.info.lines++;\n      this.state.wasRowDelimiter = false;\n    }\n  }\n  __onRecord() {\n    const {\n      columns,\n      columns_duplicates_to_array,\n      encoding,\n      info,\n      from,\n      relax_column_count,\n      relax_column_count_less,\n      relax_column_count_more,\n      raw,\n      skip_lines_with_empty_values\n    } = this.options;\n    const {\n      enabled,\n      record\n    } = this.state;\n    if (enabled === false) {\n      return this.__resetRecord();\n    }\n    // Convert the first line into column names\n    const recordLength = record.length;\n    if (columns === true) {\n      if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {\n        this.__resetRecord();\n        return;\n      }\n      return this.__firstLineToColumns(record);\n    }\n    if (columns === false && this.info.records === 0) {\n      this.state.expectedRecordLength = recordLength;\n    }\n    if (recordLength !== this.state.expectedRecordLength) {\n      const err = columns === false ?\n      // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to\n      // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\n      new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', ['Invalid Record Length:', \"expect \".concat(this.state.expectedRecordLength, \",\"), \"got \".concat(recordLength, \" on line \").concat(this.info.lines)], this.options, this.__infoField(), {\n        record: record\n      }) :\n      // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to\n      // CSV_RECORD_INCONSISTENT_COLUMNS\n      new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', ['Invalid Record Length:', \"columns length is \".concat(columns.length, \",\"), // rename columns\n      \"got \".concat(recordLength, \" on line \").concat(this.info.lines)], this.options, this.__infoField(), {\n        record: record\n      });\n      if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n        this.info.invalid_field_length++;\n        this.state.error = err;\n        // Error is undefined with skip_lines_with_error\n      } else {\n        const finalErr = this.__error(err);\n        if (finalErr) return finalErr;\n      }\n    }\n    if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {\n      this.__resetRecord();\n      return;\n    }\n    if (this.state.recordHasError === true) {\n      this.__resetRecord();\n      this.state.recordHasError = false;\n      return;\n    }\n    this.info.records++;\n    if (from === 1 || this.info.records >= from) {\n      // With columns, records are object\n      if (columns !== false) {\n        const obj = {};\n        // Transform record array to an object\n        for (let i = 0, l = record.length; i < l; i++) {\n          if (columns[i] === undefined || columns[i].disabled) continue;\n          // Turn duplicate columns into an array\n          if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {\n            if (Array.isArray(obj[columns[i].name])) {\n              obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n            } else {\n              obj[columns[i].name] = [obj[columns[i].name], record[i]];\n            }\n          } else {\n            obj[columns[i].name] = record[i];\n          }\n        }\n        const {\n          objname\n        } = this.options;\n        // Without objname (default)\n        if (objname === undefined) {\n          if (raw === true || info === true) {\n            const err = this.__push(Object.assign({\n              record: obj\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {}));\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(obj);\n            if (err) {\n              return err;\n            }\n          }\n          // With objname (default)\n        } else {\n          if (raw === true || info === true) {\n            const err = this.__push(Object.assign({\n              record: [obj[objname], obj]\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {}));\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push([obj[objname], obj]);\n            if (err) {\n              return err;\n            }\n          }\n        }\n        // Without columns, records are array\n      } else {\n        if (raw === true || info === true) {\n          const err = this.__push(Object.assign({\n            record: record\n          }, raw === true ? {\n            raw: this.state.rawBuffer.toString(encoding)\n          } : {}, info === true ? {\n            info: this.__infoRecord()\n          } : {}));\n          if (err) {\n            return err;\n          }\n        } else {\n          const err = this.__push(record);\n          if (err) {\n            return err;\n          }\n        }\n      }\n    }\n    this.__resetRecord();\n  }\n  __firstLineToColumns(record) {\n    const {\n      firstLineToHeaders\n    } = this.state;\n    try {\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n      if (!Array.isArray(headers)) {\n        return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', \"got \".concat(JSON.stringify(headers))], this.options, this.__infoField(), {\n          headers: headers\n        }));\n      }\n      const normalizedHeaders = normalizeColumnsArray(headers);\n      this.state.expectedRecordLength = normalizedHeaders.length;\n      this.options.columns = normalizedHeaders;\n      this.__resetRecord();\n      return;\n    } catch (err) {\n      return err;\n    }\n  }\n  __resetRecord() {\n    if (this.options.raw === true) {\n      this.state.rawBuffer.reset();\n    }\n    this.state.error = undefined;\n    this.state.record = [];\n    this.state.record_length = 0;\n  }\n  __onField() {\n    const {\n      cast,\n      encoding,\n      rtrim,\n      max_record_size\n    } = this.options;\n    const {\n      enabled,\n      wasQuoting\n    } = this.state;\n    // Short circuit for the from_line options\n    if (enabled === false) {\n      return this.__resetField();\n    }\n    let field = this.state.field.toString(encoding);\n    if (rtrim === true && wasQuoting === false) {\n      field = field.trimRight();\n    }\n    if (cast === true) {\n      const [err, f] = this.__cast(field);\n      if (err !== undefined) return err;\n      field = f;\n    }\n    this.state.record.push(field);\n    // Increment record length if record size must not exceed a limit\n    if (max_record_size !== 0 && typeof field === 'string') {\n      this.state.record_length += field.length;\n    }\n    this.__resetField();\n  }\n  __resetField() {\n    this.state.field.reset();\n    this.state.wasQuoting = false;\n  }\n  __push(record) {\n    const {\n      on_record\n    } = this.options;\n    if (on_record !== undefined) {\n      const info = this.__infoRecord();\n      try {\n        record = on_record.call(null, record, info);\n      } catch (err) {\n        return err;\n      }\n      if (record === undefined || record === null) {\n        return;\n      }\n    }\n    this.push(record);\n  }\n  // Return a tuple with the error and the casted value\n  __cast(field) {\n    const {\n      columns,\n      relax_column_count\n    } = this.options;\n    const isColumns = Array.isArray(columns);\n    // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n    if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n      return [undefined, undefined];\n    }\n    if (this.state.castField !== null) {\n      try {\n        const info = this.__infoField();\n        return [undefined, this.state.castField.call(null, field, info)];\n      } catch (err) {\n        return [err];\n      }\n    }\n    if (this.__isFloat(field)) {\n      return [undefined, parseFloat(field)];\n    } else if (this.options.cast_date !== false) {\n      const info = this.__infoField();\n      return [undefined, this.options.cast_date.call(null, field, info)];\n    }\n    return [undefined, field];\n  }\n  // Helper to test if a character is a space or a line delimiter\n  __isCharTrimable(chr) {\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np;\n  }\n  // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n  __isFloat(value) {\n    return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n  }\n  __compareBytes(sourceBuf, targetBuf, targetPos, firstByte) {\n    if (sourceBuf[0] !== firstByte) return 0;\n    const sourceLength = sourceBuf.length;\n    for (let i = 1; i < sourceLength; i++) {\n      if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n    }\n    return sourceLength;\n  }\n  __needMoreData(i, bufLen, end) {\n    if (end) return false;\n    const {\n      quote\n    } = this.options;\n    const {\n      quoting,\n      needMoreDataSize,\n      recordDelimiterMaxLength\n    } = this.state;\n    const numOfCharLeft = bufLen - i - 1;\n    const requiredLength = Math.max(needMoreDataSize,\n    // Skip if the remaining buffer smaller than record delimiter\n    recordDelimiterMaxLength,\n    // Skip if the remaining buffer can be record delimiter following the closing quote\n    // 1 is for quote.length\n    quoting ? quote.length + recordDelimiterMaxLength : 0);\n    return numOfCharLeft < requiredLength;\n  }\n  __isDelimiter(buf, pos, chr) {\n    const {\n      delimiter,\n      ignore_last_delimiters\n    } = this.options;\n    if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {\n      return 0;\n    } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {\n      return 0;\n    }\n    loop1: for (let i = 0; i < delimiter.length; i++) {\n      const del = delimiter[i];\n      if (del[0] === chr) {\n        for (let j = 1; j < del.length; j++) {\n          if (del[j] !== buf[pos + j]) continue loop1;\n        }\n        return del.length;\n      }\n    }\n    return 0;\n  }\n  __isRecordDelimiter(chr, buf, pos) {\n    const {\n      record_delimiter\n    } = this.options;\n    const recordDelimiterLength = record_delimiter.length;\n    loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n      const rd = record_delimiter[i];\n      const rdLength = rd.length;\n      if (rd[0] !== chr) {\n        continue;\n      }\n      for (let j = 1; j < rdLength; j++) {\n        if (rd[j] !== buf[pos + j]) {\n          continue loop1;\n        }\n      }\n      return rd.length;\n    }\n    return 0;\n  }\n  __isEscape(buf, pos, chr) {\n    const {\n      escape\n    } = this.options;\n    if (escape === null) return false;\n    const l = escape.length;\n    if (escape[0] === chr) {\n      for (let i = 0; i < l; i++) {\n        if (escape[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  __isQuote(buf, pos) {\n    const {\n      quote\n    } = this.options;\n    if (quote === null) return false;\n    const l = quote.length;\n    for (let i = 0; i < l; i++) {\n      if (quote[i] !== buf[pos + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  __autoDiscoverRecordDelimiter(buf, pos) {\n    const {\n      encoding\n    } = this.options;\n    const chr = buf[pos];\n    if (chr === cr) {\n      if (buf[pos + 1] === nl) {\n        this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding));\n        this.state.recordDelimiterMaxLength = 2;\n        return 2;\n      } else {\n        this.options.record_delimiter.push(Buffer.from('\\r', encoding));\n        this.state.recordDelimiterMaxLength = 1;\n        return 1;\n      }\n    } else if (chr === nl) {\n      this.options.record_delimiter.push(Buffer.from('\\n', encoding));\n      this.state.recordDelimiterMaxLength = 1;\n      return 1;\n    }\n    return 0;\n  }\n  __error(msg) {\n    const {\n      skip_lines_with_error\n    } = this.options;\n    const err = typeof msg === 'string' ? new Error(msg) : msg;\n    if (skip_lines_with_error) {\n      this.state.recordHasError = true;\n      this.emit('skip', err);\n      return undefined;\n    } else {\n      return err;\n    }\n  }\n  __infoDataSet() {\n    return {\n      ...this.info,\n      columns: this.options.columns\n    };\n  }\n  __infoRecord() {\n    const {\n      columns\n    } = this.options;\n    return {\n      ...this.__infoDataSet(),\n      error: this.state.error,\n      header: columns === true,\n      index: this.state.record.length\n    };\n  }\n  __infoField() {\n    const {\n      columns\n    } = this.options;\n    const isColumns = Array.isArray(columns);\n    return {\n      ...this.__infoRecord(),\n      column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n      quoting: this.state.wasQuoting\n    };\n  }\n}\nconst parse = function () {\n  let data, options, callback;\n  for (let i in arguments) {\n    const argument = arguments[i];\n    const type = typeof argument;\n    if (data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', \"got \".concat(JSON.stringify(argument), \" at index \").concat(i)], options || {});\n    }\n  }\n  const parser = new Parser(options);\n  if (callback) {\n    const records = options === undefined || options.objname === undefined ? [] : {};\n    parser.on('readable', function () {\n      let record;\n      while ((record = this.read()) !== null) {\n        if (options === undefined || options.objname === undefined) {\n          records.push(record);\n        } else {\n          records[record[0]] = record[1];\n        }\n      }\n    });\n    parser.on('error', function (err) {\n      callback(err, undefined, parser.__infoDataSet());\n    });\n    parser.on('end', function () {\n      callback(undefined, records, parser.__infoDataSet());\n    });\n  }\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        parser.write(data);\n        parser.end();\n      });\n    } else {\n      parser.write(data);\n      parser.end();\n    }\n  }\n  return parser;\n};\nclass CsvError extends Error {\n  constructor(code, message, options) {\n    if (Array.isArray(message)) message = message.join(' ');\n    super(message);\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for (var _len = arguments.length, contexts = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      contexts[_key - 3] = arguments[_key];\n    }\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\nparse.Parser = Parser;\nparse.CsvError = CsvError;\nmodule.exports = parse;\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n};\nconst isObject = function (obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\nconst isRecordEmpty = function (record) {\n  return record.every(field => field == null || field.toString && field.toString().trim() === '');\n};\nconst normalizeColumnsArray = function (columns) {\n  const normalizedColumns = [];\n  for (let i = 0, l = columns.length; i < l; i++) {\n    const column = columns[i];\n    if (column === undefined || column === null || column === false) {\n      normalizedColumns[i] = {\n        disabled: true\n      };\n    } else if (typeof column === 'string') {\n      normalizedColumns[i] = {\n        name: column\n      };\n    } else if (isObject(column)) {\n      if (typeof column.name !== 'string') {\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', ['Option columns missing name:', \"property \\\"name\\\" is required at position \".concat(i), 'when column is an object literal']);\n      }\n      normalizedColumns[i] = column;\n    } else {\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', ['Invalid column definition:', 'expect a string or a literal object,', \"got \".concat(JSON.stringify(column), \" at position \").concat(i)]);\n    }\n  }\n  return normalizedColumns;\n};","map":{"version":3,"names":["Transform","require","ResizeableBuffer","tab","nl","np","cr","space","boms","Buffer","from","Parser","constructor","opts","arguments","length","undefined","readableObjectMode","encoding","__originalOptions","__normalizeOptions","options","opt","underscore","CsvError","concat","JSON","stringify","bom","fnCastField","cast","cast_date","value","date","Date","parse","isNaN","fnFirstLineToHeaders","columns","Array","isArray","normalizeColumnsArray","columns_duplicates_to_array","comment","isBuffer","delimiter_json","delimiter","map","escape","Error","test","parseInt","Number","isInteger","from_line","ignore_last_delimiters","Math","floor","info","max_record_size","objname","toString","on_record","quote","raw","record_delimiter","rd","relax","relax_column_count","relax_column_count_less","relax_column_count_more","skip_empty_lines","skip_lines_with_empty_values","skip_lines_with_error","rtrim","ltrim","trim","to","to_line","bytes","comment_lines","empty_lines","invalid_field_length","lines","records","state","bomSkipped","bufBytesStart","castField","commenting","error","enabled","escaping","escapeIsQuote","compare","expectedRecordLength","field","firstLineToHeaders","needMoreDataSize","max","previousBuf","quoting","stop","rawBuffer","record","recordHasError","record_length","recordDelimiterMaxLength","v","trimChars","wasQuoting","wasRowDelimiter","_transform","buf","callback","err","__parse","_flush","nextBuf","end","push","bomLength","slice","bufLen","pos","__needMoreData","record_delimiterCount","__autoDiscoverRecordDelimiter","chr","append","__isEscape","__isQuote","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRecordDelimiter","__isRecordDelimiter","__error","String","fromCharCode","__infoField","prepend","recordDelimiterLength","skipCommentLine","__resetField","__resetRecord","errField","__onField","errRecord","__onRecord","commentCount","delimiterLength","lappend","rappend","recordLength","isRecordEmpty","__firstLineToColumns","finalErr","obj","i","l","disabled","name","__push","Object","assign","__infoRecord","headers","call","normalizedHeaders","reset","trimRight","f","__cast","isColumns","__isFloat","parseFloat","sourceBuf","targetBuf","targetPos","firstByte","sourceLength","numOfCharLeft","requiredLength","loop1","del","j","rdLength","msg","emit","__infoDataSet","header","index","column","data","argument","type","isObject","parser","on","read","setImmediate","write","code","message","join","captureStackTrace","_len","contexts","_key","context","key","module","exports","str","replace","_","match","toLowerCase","every","normalizedColumns"],"sources":["C:/Users/Starskvim/WebstormProjects/product-list/node_modules/csv-parse/lib/index.js"],"sourcesContent":["\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst ResizeableBuffer = require('./ResizeableBuffer')\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst tab = 9\nconst nl = 10 // \\n, 0x0A in hexadecimal, 10 in decimal\nconst np = 12\nconst cr = 13 // \\r, 0x0D in hexadÃ©cimal, 13 in decimal\nconst space = 32\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n}\n\nclass Parser extends Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts, encoding: null})\n    this.__originalOptions = opts\n    this.__normalizeOptions(opts)\n  }\n  __normalizeOptions(opts){\n    const options = {}\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    // Normalize option `encoding`\n    // Note: defined first because other options depends on it\n    // to convert chars/strings into buffers.\n    if(options.encoding === undefined || options.encoding === true){\n      options.encoding = 'utf8'\n    }else if(options.encoding === null || options.encoding === false){\n      options.encoding = null\n    }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n      throw new CsvError('CSV_INVALID_OPTION_ENCODING', [\n        'Invalid option encoding:',\n        'encoding must be a string or null to return a buffer,',\n        `got ${JSON.stringify(options.encoding)}`\n      ], options)\n    }\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      throw new CsvError('CSV_INVALID_OPTION_BOM', [\n        'Invalid option bom:', 'bom must be true,',\n        `got ${JSON.stringify(options.bom)}`\n      ], options)\n    }\n    // Normalize option `cast`\n    let fnCastField = null\n    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n      options.cast = undefined\n    }else if(typeof options.cast === 'function'){\n      fnCastField = options.cast\n      options.cast = true\n    }else if(options.cast !== true){\n      throw new CsvError('CSV_INVALID_OPTION_CAST', [\n        'Invalid option cast:', 'cast must be true or a function,',\n        `got ${JSON.stringify(options.cast)}`\n      ], options)\n    }\n    // Normalize option `cast_date`\n    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n      options.cast_date = false\n    }else if(options.cast_date === true){\n      options.cast_date = function(value){\n        const date = Date.parse(value)\n        return !isNaN(date) ? new Date(date) : value\n      }\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n        'Invalid option cast_date:', 'cast_date must be true or a function,',\n        `got ${JSON.stringify(options.cast_date)}`\n      ], options)\n    }\n    // Normalize option `columns`\n    let fnFirstLineToHeaders = null\n    if(options.columns === true){\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined\n    }else if(typeof options.columns === 'function'){\n      fnFirstLineToHeaders = options.columns\n      options.columns = true\n    }else if(Array.isArray(options.columns)){\n      options.columns = normalizeColumnsArray(options.columns)\n    }else if(options.columns === undefined || options.columns === null || options.columns === false){\n      options.columns = false\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n        'Invalid option columns:',\n        'expect an array, a function or true,',\n        `got ${JSON.stringify(options.columns)}`\n      ], options)\n    }\n    // Normalize option `columns_duplicates_to_array`\n    if(options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false){\n      options.columns_duplicates_to_array = false\n    }else if(options.columns_duplicates_to_array !== true){\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [\n        'Invalid option columns_duplicates_to_array:',\n        'expect an boolean,',\n        `got ${JSON.stringify(options.columns_duplicates_to_array)}`\n      ], options)\n    }else if(options.columns === false){\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [\n        'Invalid option columns_duplicates_to_array:',\n        'the `columns` mode must be activated.'\n      ], options)\n    }\n    // Normalize option `comment`\n    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n      options.comment = null\n    }else{\n      if(typeof options.comment === 'string'){\n        options.comment = Buffer.from(options.comment, options.encoding)\n      }\n      if(!Buffer.isBuffer(options.comment)){\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n          'Invalid option comment:',\n          'comment must be a buffer or a string,',\n          `got ${JSON.stringify(options.comment)}`\n        ], options)\n      }\n    }\n    // Normalize option `delimiter`\n    const delimiter_json = JSON.stringify(options.delimiter)\n    if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter]\n    if(options.delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options)\n    }\n    options.delimiter = options.delimiter.map(function(delimiter){\n      if(delimiter === undefined || delimiter === null || delimiter === false){\n        return Buffer.from(',', options.encoding)\n      }\n      if(typeof delimiter === 'string'){\n        delimiter = Buffer.from(delimiter, options.encoding)\n      }\n      if( !Buffer.isBuffer(delimiter) || delimiter.length === 0){\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n          'Invalid option delimiter:',\n          'delimiter must be a non empty string or buffer or array of string|buffer,',\n          `got ${delimiter_json}`\n        ], options)\n      }\n      return delimiter\n    })\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === true){\n      options.escape = Buffer.from('\"', options.encoding)\n    }else if(typeof options.escape === 'string'){\n      options.escape = Buffer.from(options.escape, options.encoding)\n    }else if (options.escape === null || options.escape === false){\n      options.escape = null\n    }\n    if(options.escape !== null){\n      if(!Buffer.isBuffer(options.escape)){\n        throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`)\n      }\n    }\n    // Normalize option `from`\n    if(options.from === undefined || options.from === null){\n      options.from = 1\n    }else{\n      if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n        options.from = parseInt(options.from)\n      }\n      if(Number.isInteger(options.from)){\n        if(options.from < 0){\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)\n      }\n    }\n    // Normalize option `from_line`\n    if(options.from_line === undefined || options.from_line === null){\n      options.from_line = 1\n    }else{\n      if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n        options.from_line = parseInt(options.from_line)\n      }\n      if(Number.isInteger(options.from_line)){\n        if(options.from_line <= 0){\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)\n      }\n    }\n    // Normalize options `ignore_last_delimiters`\n    if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n      options.ignore_last_delimiters = false\n    }else if(typeof options.ignore_last_delimiters === 'number'){\n      options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters)\n      if(options.ignore_last_delimiters === 0){\n        options.ignore_last_delimiters = false\n      }\n    }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n      throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n        'Invalid option `ignore_last_delimiters`:',\n        'the value must be a boolean value or an integer,',\n        `got ${JSON.stringify(options.ignore_last_delimiters)}`\n      ], options)\n    }\n    if(options.ignore_last_delimiters === true && options.columns === false){\n      throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n        'The option `ignore_last_delimiters`',\n        'requires the activation of the `columns` option'\n      ], options)\n    }\n    // Normalize option `info`\n    if(options.info === undefined || options.info === null || options.info === false){\n      options.info = false\n    }else if(options.info !== true){\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)\n    }\n    // Normalize option `max_record_size`\n    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n      options.max_record_size = 0\n    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n      // Great, nothing to do\n    }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n      options.max_record_size = parseInt(options.max_record_size)\n    }else{\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)\n    }\n    // Normalize option `objname`\n    if(options.objname === undefined || options.objname === null || options.objname === false){\n      options.objname = undefined\n    }else if(Buffer.isBuffer(options.objname)){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty buffer`)\n      }\n      if(options.encoding === null){\n        // Don't call `toString`, leave objname as a buffer\n      }else{\n        options.objname = options.objname.toString(options.encoding)\n      }\n    }else if(typeof options.objname === 'string'){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty string`)\n      }\n      // Great, nothing to do\n    }else{\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)\n    }\n    // Normalize option `on_record`\n    if(options.on_record === undefined || options.on_record === null){\n      options.on_record = undefined\n    }else if(typeof options.on_record !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n        'Invalid option `on_record`:',\n        'expect a function,',\n        `got ${JSON.stringify(options.on_record)}`\n      ], options)\n    }\n    // Normalize option `quote`\n    if(options.quote === null || options.quote === false || options.quote === ''){\n      options.quote = null\n    }else{\n      if(options.quote === undefined || options.quote === true){\n        options.quote = Buffer.from('\"', options.encoding)\n      }else if(typeof options.quote === 'string'){\n        options.quote = Buffer.from(options.quote, options.encoding)\n      }\n      if(!Buffer.isBuffer(options.quote)){\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)\n      }\n    }\n    // Normalize option `raw`\n    if(options.raw === undefined || options.raw === null || options.raw === false){\n      options.raw = false\n    }else if(options.raw !== true){\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)\n    }\n    // Normalize option `record_delimiter`\n    if(!options.record_delimiter){\n      options.record_delimiter = []\n    }else if(!Array.isArray(options.record_delimiter)){\n      options.record_delimiter = [options.record_delimiter]\n    }\n    options.record_delimiter = options.record_delimiter.map( function(rd){\n      if(typeof rd === 'string'){\n        rd = Buffer.from(rd, options.encoding)\n      }\n      return rd\n    })\n    // Normalize option `relax`\n    if(typeof options.relax === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax === undefined || options.relax === null){\n      options.relax = false\n    }else{\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)\n    }\n    // Normalize option `relax_column_count`\n    if(typeof options.relax_column_count === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n      options.relax_column_count = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)\n    }\n    if(typeof options.relax_column_count_less === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n      options.relax_column_count_less = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`)\n    }\n    if(typeof options.relax_column_count_more === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n      options.relax_column_count_more = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`)\n    }\n    // Normalize option `skip_empty_lines`\n    if(typeof options.skip_empty_lines === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n      options.skip_empty_lines = false\n    }else{\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)\n    }\n    // Normalize option `skip_lines_with_empty_values`\n    if(typeof options.skip_lines_with_empty_values === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){\n      options.skip_lines_with_empty_values = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)\n    }\n    // Normalize option `skip_lines_with_error`\n    if(typeof options.skip_lines_with_error === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){\n      options.skip_lines_with_error = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)\n    }\n    // Normalize option `rtrim`\n    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n      options.rtrim = false\n    }else if(options.rtrim !== true){\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)\n    }\n    // Normalize option `ltrim`\n    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n      options.ltrim = false\n    }else if(options.ltrim !== true){\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)\n    }\n    // Normalize option `trim`\n    if(options.trim === undefined || options.trim === null || options.trim === false){\n      options.trim = false\n    }else if(options.trim !== true){\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)\n    }\n    // Normalize options `trim`, `ltrim` and `rtrim`\n    if(options.trim === true && opts.ltrim !== false){\n      options.ltrim = true\n    }else if(options.ltrim !== true){\n      options.ltrim = false\n    }\n    if(options.trim === true && opts.rtrim !== false){\n      options.rtrim = true\n    }else if(options.rtrim !== true){\n      options.rtrim = false\n    }\n    // Normalize option `to`\n    if(options.to === undefined || options.to === null){\n      options.to = -1\n    }else{\n      if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n        options.to = parseInt(options.to)\n      }\n      if(Number.isInteger(options.to)){\n        if(options.to <= 0){\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)\n      }\n    }\n    // Normalize option `to_line`\n    if(options.to_line === undefined || options.to_line === null){\n      options.to_line = -1\n    }else{\n      if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n        options.to_line = parseInt(options.to_line)\n      }\n      if(Number.isInteger(options.to_line)){\n        if(options.to_line <= 0){\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)\n      }\n    }\n    this.info = {\n      bytes: 0,\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    }\n    this.options = options\n    this.state = {\n      bomSkipped: false,\n      bufBytesStart: 0,\n      castField: fnCastField,\n      commenting: false,\n      // Current error encountered by a record\n      error: undefined,\n      enabled: options.from_line === 1,\n      escaping: false,\n      // escapeIsQuote: options.escape === options.quote,\n      escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n      // columns can be `false`, `true`, `Array`\n      expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      needMoreDataSize: Math.max(\n        // Skip if the remaining buffer smaller than comment\n        options.comment !== null ? options.comment.length : 0,\n        // Skip if the remaining buffer can be delimiter\n        ...options.delimiter.map( (delimiter) => delimiter.length),\n        // Skip if the remaining buffer can be escape sequence\n        options.quote !== null ? options.quote.length : 0,\n      ),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),\n      trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    }\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(buf, false)\n    if(err !== undefined){\n      this.state.stop = true\n    }\n    callback(err)\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(undefined, true)\n    callback(err)\n  }\n  // Central parser implementation\n  __parse(nextBuf, end){\n    const {bom, comment, escape, from_line, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options\n    let {record_delimiter} = this.options\n    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state\n    let buf\n    if(previousBuf === undefined){\n      if(nextBuf === undefined){\n        // Handle empty string\n        this.push(null)\n        return\n      }else{\n        buf = nextBuf\n      }\n    }else if(previousBuf !== undefined && nextBuf === undefined){\n      buf = previousBuf\n    }else{\n      buf = Buffer.concat([previousBuf, nextBuf])\n    }\n    // Handle UTF BOM\n    if(bomSkipped === false){\n      if(bom === false){\n        this.state.bomSkipped = true\n      }else if(buf.length < 3){\n        // No enough data\n        if(end === false){\n          // Wait for more data\n          this.state.previousBuf = buf\n          return\n        }\n      }else{\n        for(let encoding in boms){\n          if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n            // Skip BOM\n            let bomLength = boms[encoding].length\n            this.state.bufBytesStart += bomLength\n            buf = buf.slice(bomLength)\n            // Renormalize original options with the new encoding\n            this.__normalizeOptions({...this.__originalOptions, encoding: encoding})\n            break\n          }\n        }\n        this.state.bomSkipped = true\n      }\n    }\n    const bufLen = buf.length\n    let pos\n    for(pos = 0; pos < bufLen; pos++){\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if(this.__needMoreData(pos, bufLen, end)){\n        break\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++\n        this.state.wasRowDelimiter = false\n      }\n      if(to_line !== -1 && this.info.lines > to_line){\n        this.state.stop = true\n        this.push(null)\n        return\n      }\n      // Auto discovery of record_delimiter, unix, mac and windows supported\n      if(this.state.quoting === false && record_delimiter.length === 0){\n        const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos)\n        if(record_delimiterCount){\n          record_delimiter = this.options.record_delimiter\n        }\n      }\n      const chr = buf[pos]\n      if(raw === true){\n        rawBuffer.append(chr)\n      }\n      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){\n        this.state.wasRowDelimiter = true\n      }\n      // Previous char was a valid escape char\n      // treat the current char as a regular char\n      if(this.state.escaping === true){\n        this.state.escaping = false\n      }else{\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n        if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n          if(escapeIsQuote){\n            if(this.__isQuote(buf, pos+escape.length)){\n              this.state.escaping = true\n              pos += escape.length - 1\n              continue\n            }\n          }else{\n            this.state.escaping = true\n            pos += escape.length - 1\n            continue\n          }\n        }\n        // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n        if(this.state.commenting === false && this.__isQuote(buf, pos)){\n          if(this.state.quoting === true){\n            const nextChr = buf[pos+quote.length]\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr)\n            const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr)\n            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length)\n            // Escape a quote\n            // Treat next char as a regular character\n            if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n              pos += escape.length - 1\n            }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              pos += quote.length - 1\n              continue\n            }else if(relax === false){\n              const err = this.__error(\n                new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                  'Invalid Closing Quote:',\n                  `got \"${String.fromCharCode(nextChr)}\"`,\n                  `at line ${this.info.lines}`,\n                  'instead of delimiter, record delimiter, trimable character',\n                  '(if activated) or comment',\n                ], this.options, this.__infoField())\n              )\n              if(err !== undefined) return err\n            }else{\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              this.state.field.prepend(quote)\n              pos += quote.length - 1\n            }\n          }else{\n            if(this.state.field.length !== 0){\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if( relax === false ){\n                const err = this.__error(\n                  new CsvError('INVALID_OPENING_QUOTE', [\n                    'Invalid Opening Quote:',\n                    `a quote is found inside a field at line ${this.info.lines}`,\n                  ], this.options, this.__infoField(), {\n                    field: this.state.field,\n                  })\n                )\n                if(err !== undefined) return err\n              }\n            }else{\n              this.state.quoting = true\n              pos += quote.length - 1\n              continue\n            }\n          }\n        }\n        if(this.state.quoting === false){\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)\n          if(recordDelimiterLength !== 0){\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)\n            if(skipCommentLine){\n              this.info.comment_lines++\n              // Skip full comment line\n            }else{\n              // Activate records emition if above from_line\n              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                this.state.enabled = true\n                this.__resetField()\n                this.__resetRecord()\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              // Skip if line is empty and skip_empty_lines activated\n              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                this.info.empty_lines++\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField()\n              if(errField !== undefined) return errField\n              this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n              const errRecord = this.__onRecord()\n              if(errRecord !== undefined) return errRecord\n              if(to !== -1 && this.info.records >= to){\n                this.state.stop = true\n                this.push(null)\n                return\n              }\n            }\n            this.state.commenting = false\n            pos += recordDelimiterLength - 1\n            continue\n          }\n          if(this.state.commenting){\n            continue\n          }\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)\n          if(commentCount !== 0){\n            this.state.commenting = true\n            continue\n          }\n          let delimiterLength = this.__isDelimiter(buf, pos, chr)\n          if(delimiterLength !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField()\n            if(errField !== undefined) return errField\n            pos += delimiterLength - 1\n            continue\n          }\n        }\n      }\n      if(this.state.commenting === false){\n        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n          const err = this.__error(\n            new CsvError('CSV_MAX_RECORD_SIZE', [\n              'Max Record Size:',\n              'record exceed the maximum number of tolerated bytes',\n              `of ${max_record_size}`,\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          )\n          if(err !== undefined) return err\n        }\n      }\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)\n      // rtrim in non quoting is handle in __onField\n      const rappend = rtrim === false || this.state.wasQuoting === false\n      if( lappend === true && rappend === true ){\n        this.state.field.append(chr)\n      }else if(rtrim === true && !this.__isCharTrimable(chr)){\n        const err = this.__error(\n          new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n            'Invalid Closing Quote:',\n            'found non trimable byte after quote',\n            `at line ${this.info.lines}`,\n          ], this.options, this.__infoField())\n        )\n        if(err !== undefined) return err\n      }\n    }\n    if(end === true){\n      // Ensure we are not ending in a quoting state\n      if(this.state.quoting === true){\n        const err = this.__error(\n          new CsvError('CSV_QUOTE_NOT_CLOSED', [\n            'Quote Not Closed:',\n            `the parsing is finished with an opening quote at line ${this.info.lines}`,\n          ], this.options, this.__infoField())\n        )\n        if(err !== undefined) return err\n      }else{\n        // Skip last line if it has no characters\n        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n          this.info.bytes = this.state.bufBytesStart + pos;\n          const errField = this.__onField()\n          if(errField !== undefined) return errField\n          const errRecord = this.__onRecord()\n          if(errRecord !== undefined) return errRecord\n        }else if(this.state.wasRowDelimiter === true){\n          this.info.empty_lines++\n        }else if(this.state.commenting === true){\n          this.info.comment_lines++\n        }\n      }\n    }else{\n      this.state.bufBytesStart += pos\n      this.state.previousBuf = buf.slice(pos)\n    }\n    if(this.state.wasRowDelimiter === true){\n      this.info.lines++\n      this.state.wasRowDelimiter = false\n    }\n  }\n  __onRecord(){\n    const {columns, columns_duplicates_to_array, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values} = this.options\n    const {enabled, record} = this.state\n    if(enabled === false){\n      return this.__resetRecord()\n    }\n    // Convert the first line into column names\n    const recordLength = record.length\n    if(columns === true){\n      if(skip_lines_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord()\n        return\n      }\n      return this.__firstLineToColumns(record)\n    }\n    if(columns === false && this.info.records === 0){\n      this.state.expectedRecordLength = recordLength\n    }\n    if(recordLength !== this.state.expectedRecordLength){\n      const err = columns === false ?\n        // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to\n        // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\n        new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', [\n          'Invalid Record Length:',\n          `expect ${this.state.expectedRecordLength},`,\n          `got ${recordLength} on line ${this.info.lines}`,\n        ], this.options, this.__infoField(), {\n          record: record,\n        })\n      :\n        // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to\n        // CSV_RECORD_INCONSISTENT_COLUMNS\n        new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', [\n          'Invalid Record Length:',\n          `columns length is ${columns.length},`, // rename columns\n          `got ${recordLength} on line ${this.info.lines}`,\n        ], this.options, this.__infoField(), {\n          record: record,\n        })\n      if(relax_column_count === true ||\n        (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n        (relax_column_count_more === true && recordLength > this.state.expectedRecordLength) ){\n        this.info.invalid_field_length++\n        this.state.error = err\n      // Error is undefined with skip_lines_with_error\n      }else{\n        const finalErr = this.__error(err)\n        if(finalErr) return finalErr\n      }\n    }\n    if(skip_lines_with_empty_values === true && isRecordEmpty(record)){\n      this.__resetRecord()\n      return\n    }\n    if(this.state.recordHasError === true){\n      this.__resetRecord()\n      this.state.recordHasError = false\n      return\n    }\n    this.info.records++\n    if(from === 1 || this.info.records >= from){\n      // With columns, records are object\n      if(columns !== false){\n        const obj = {}\n        // Transform record array to an object\n        for(let i = 0, l = record.length; i < l; i++){\n          if(columns[i] === undefined || columns[i].disabled) continue\n          // Turn duplicate columns into an array\n          if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {\n            if (Array.isArray(obj[columns[i].name])) {\n              obj[columns[i].name] = obj[columns[i].name].concat(record[i])\n            } else {\n              obj[columns[i].name] = [obj[columns[i].name], record[i]]\n            }\n          } else {\n            obj[columns[i].name] = record[i]\n          }\n        }\n        const {objname} = this.options\n        // Without objname (default)\n        if(objname === undefined){\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push(obj)\n            if(err){\n              return err\n            }\n          }\n        // With objname (default)\n        }else{\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: [obj[objname], obj]},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push([obj[objname], obj])\n            if(err){\n              return err\n            }\n          }\n        }\n      // Without columns, records are array\n      }else{\n        if(raw === true || info === true){\n          const err = this.__push(Object.assign(\n            {record: record},\n            raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n            info === true ? {info: this.__infoRecord()}: {}\n          ))\n          if(err){\n            return err\n          }\n        }else{\n          const err = this.__push(record)\n          if(err){\n            return err\n          }\n        }\n      }\n    }\n    this.__resetRecord()\n  }\n  __firstLineToColumns(record){\n    const {firstLineToHeaders} = this.state\n    try{\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)\n      if(!Array.isArray(headers)){\n        return this.__error(\n          new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n            'Invalid Column Mapping:',\n            'expect an array from column function,',\n            `got ${JSON.stringify(headers)}`\n          ], this.options, this.__infoField(), {\n            headers: headers,\n          })\n        )\n      }\n      const normalizedHeaders = normalizeColumnsArray(headers)\n      this.state.expectedRecordLength = normalizedHeaders.length\n      this.options.columns = normalizedHeaders\n      this.__resetRecord()\n      return\n    }catch(err){\n      return err\n    }\n  }\n  __resetRecord(){\n    if(this.options.raw === true){\n      this.state.rawBuffer.reset()\n    }\n    this.state.error = undefined\n    this.state.record = []\n    this.state.record_length = 0\n  }\n  __onField(){\n    const {cast, encoding, rtrim, max_record_size} = this.options\n    const {enabled, wasQuoting} = this.state\n    // Short circuit for the from_line options\n    if(enabled === false){\n      return this.__resetField()\n    }\n    let field = this.state.field.toString(encoding)\n    if(rtrim === true && wasQuoting === false){\n      field = field.trimRight()\n    }\n    if(cast === true){\n      const [err, f] = this.__cast(field)\n      if(err !== undefined) return err\n      field = f\n    }\n    this.state.record.push(field)\n    // Increment record length if record size must not exceed a limit\n    if(max_record_size !== 0 && typeof field === 'string'){\n      this.state.record_length += field.length\n    }\n    this.__resetField()\n  }\n  __resetField(){\n    this.state.field.reset()\n    this.state.wasQuoting = false\n  }\n  __push(record){\n    const {on_record} = this.options\n    if(on_record !== undefined){\n      const info = this.__infoRecord()\n      try{\n        record = on_record.call(null, record, info)\n      }catch(err){\n        return err\n      }\n      if(record === undefined || record === null){ return }\n    }\n    this.push(record)\n  }\n  // Return a tuple with the error and the casted value\n  __cast(field){\n    const {columns, relax_column_count} = this.options\n    const isColumns = Array.isArray(columns)\n    // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n    if( isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length ){\n      return [undefined, undefined]\n    }\n    if(this.state.castField !== null){\n      try{\n        const info = this.__infoField()\n        return [undefined, this.state.castField.call(null, field, info)]\n      }catch(err){\n        return [err]\n      }\n    }\n    if(this.__isFloat(field)){\n      return [undefined, parseFloat(field)]\n    }else if(this.options.cast_date !== false){\n      const info = this.__infoField()\n      return [undefined, this.options.cast_date.call(null, field, info)]\n    }\n    return [undefined, field]\n  }\n  // Helper to test if a character is a space or a line delimiter\n  __isCharTrimable(chr){\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np\n  }\n  // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n  __isFloat(value){\n    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery\n  }\n  __compareBytes(sourceBuf, targetBuf, targetPos, firstByte){\n    if(sourceBuf[0] !== firstByte) return 0\n    const sourceLength = sourceBuf.length\n    for(let i = 1; i < sourceLength; i++){\n      if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0\n    }\n    return sourceLength\n  }\n  __needMoreData(i, bufLen, end){\n    if(end) return false\n    const {quote} = this.options\n    const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state\n    const numOfCharLeft = bufLen - i - 1\n    const requiredLength = Math.max(\n      needMoreDataSize,\n      // Skip if the remaining buffer smaller than record delimiter\n      recordDelimiterMaxLength,\n      // Skip if the remaining buffer can be record delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n    )\n    return numOfCharLeft < requiredLength\n  }\n  __isDelimiter(buf, pos, chr){\n    const {delimiter, ignore_last_delimiters} = this.options\n    if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n      return 0\n    }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n      return 0\n    }\n    loop1: for(let i = 0; i < delimiter.length; i++){\n      const del = delimiter[i]\n      if(del[0] === chr){\n        for(let j = 1; j < del.length; j++){\n          if(del[j] !== buf[pos+j]) continue loop1\n        }\n        return del.length\n      }\n    }\n    return 0\n  }\n  __isRecordDelimiter(chr, buf, pos){\n    const {record_delimiter} = this.options\n    const recordDelimiterLength = record_delimiter.length\n    loop1: for(let i = 0; i < recordDelimiterLength; i++){\n      const rd = record_delimiter[i]\n      const rdLength = rd.length\n      if(rd[0] !== chr){\n        continue\n      }\n      for(let j = 1; j < rdLength; j++){\n        if(rd[j] !== buf[pos+j]){\n          continue loop1\n        }\n      }\n      return rd.length\n    }\n    return 0\n  }\n  __isEscape(buf, pos, chr){\n    const {escape} = this.options\n    if(escape === null) return false\n    const l = escape.length\n    if(escape[0] === chr){\n      for(let i = 0; i < l; i++){\n        if(escape[i] !== buf[pos+i]){\n          return false\n        }\n      }\n      return true\n    }\n    return false\n  }\n  __isQuote(buf, pos){\n    const {quote} = this.options\n    if(quote === null) return false\n    const l = quote.length\n    for(let i = 0; i < l; i++){\n      if(quote[i] !== buf[pos+i]){\n        return false\n      }\n    }\n    return true\n  }\n  __autoDiscoverRecordDelimiter(buf, pos){\n    const {encoding} = this.options\n    const chr = buf[pos]\n    if(chr === cr){\n      if(buf[pos+1] === nl){\n        this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding))\n        this.state.recordDelimiterMaxLength = 2\n        return 2\n      }else{\n        this.options.record_delimiter.push(Buffer.from('\\r', encoding))\n        this.state.recordDelimiterMaxLength = 1\n        return 1\n      }\n    }else if(chr === nl){\n      this.options.record_delimiter.push(Buffer.from('\\n', encoding))\n      this.state.recordDelimiterMaxLength = 1\n      return 1\n    }\n    return 0\n  }\n  __error(msg){\n    const {skip_lines_with_error} = this.options\n    const err = typeof msg === 'string' ? new Error(msg) : msg\n    if(skip_lines_with_error){\n      this.state.recordHasError = true\n      this.emit('skip', err)\n      return undefined\n    }else{\n      return err\n    }\n  }\n  __infoDataSet(){\n    return {\n      ...this.info,\n      columns: this.options.columns\n    }\n  }\n  __infoRecord(){\n    const {columns} = this.options\n    return {\n      ...this.__infoDataSet(),\n      error: this.state.error,\n      header: columns === true,\n      index: this.state.record.length,\n    }\n  }\n  __infoField(){\n    const {columns} = this.options\n    const isColumns = Array.isArray(columns)\n    return {\n      ...this.__infoRecord(),\n      column: isColumns === true ?\n        ( columns.length > this.state.record.length ?\n          columns[this.state.record.length].name :\n          null\n        ) :\n        this.state.record.length,\n      quoting: this.state.wasQuoting,\n    }\n  }\n}\n\nconst parse = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ], options || {})\n    }\n  }\n  const parser = new Parser(options)\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {}\n    parser.on('readable', function(){\n      let record\n      while((record = this.read()) !== null){\n        if(options === undefined || options.objname === undefined){\n          records.push(record)\n        }else{\n          records[record[0]] = record[1]\n        }\n      }\n    })\n    parser.on('error', function(err){\n      callback(err, undefined, parser.__infoDataSet())\n    })\n    parser.on('end', function(){\n      callback(undefined, records, parser.__infoDataSet())\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        parser.write(data)\n        parser.end()\n      })\n    }else{\n      parser.write(data)\n      parser.end()\n    }\n  }\n  return parser\n}\n\nclass CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nparse.Parser = Parser\n\nparse.CsvError = CsvError\n\nmodule.exports = parse\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\nconst isObject = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))\n}\n\nconst isRecordEmpty = function(record){\n  return record.every( (field) => field == null || field.toString && field.toString().trim() === '' )\n}\n\nconst normalizeColumnsArray = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i]\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true }\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column }\n    }else if(isObject(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ])\n      }\n      normalizedColumns[i] = column\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ])\n    }\n  }\n  return normalizedColumns;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}